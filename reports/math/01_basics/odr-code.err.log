Traceback (most recent call last):
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\jupyter_core\utils\__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
    ~~~~~~~~~~~~~~~~~~~~~~~~^^
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
    ~~~~~~~~~^
        nb,
        ^^^
    ...<4 lines>...
        **kwargs,
        ^^^^^^^^^
    )
    ^
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\nbclient\client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\jupyter_core\utils\__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^
  File "C:\Users\Vladyslav\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py", line 725, in run_until_complete
    return future.result()
           ~~~~~~~~~~~~~^^
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\nbclient\client.py", line 709, in async_execute
    await self.async_execute_cell(
        cell, index, execution_count=self.code_cells_executed + 1
    )
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\nbclient\client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "E:\Python\physics-python-and-pi\venv\Lib\site-packages\nbclient\client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# Store the original data in the results dictionary for plotting later
results['original_x'] = x
results['original_y'] = y_obs
results['original_sigma_x'] = sigma_x
results['original_sigma_y'] = sigma_y
results['original_weights_x'] = 1.0 / (sigma_x**2)
results['original_weights_y'] = 1.0 / (sigma_y**2)

# Store results from ODR's Output object
results['odr_output'] = output
results['fit_params'] = output.beta
results['std_errs'] = output.sd_beta
results['cov_beta'] = output.cov_beta
results['number_of_observations'] = len(x)
results['number_of_parameters'] = len(output.beta)
results['degrees_of_freedom'] = results['number_of_observations'] - results['number_of_parameters']
results['inverse_condition_number'] = output.inv_condnum

# Calculate t-values and p-values
t_values = results['fit_params'] / results['std_errs']
p_values = stats.t.sf(np.abs(t_values), df=results['degrees_of_freedom']) * 2
results['t_values'] = t_values
results['p_values'] = p_values

# Chi-Squared and Reduced Chi-Squared from ODR output
results['chi_squared_odr'] = output.sum_square
results['reduced_chi_squared_odr'] = output.res_var

# Calculate Chi-Squared manually as per the formula
# ODR output provides delta (residuals in x) and eps (residuals in y)
delta_x = output.delta
epsilon_y = output.eps

chi_squared_manual = np.sum((delta_x / sigma_x)**2 + (epsilon_y / sigma_y)**2)
results['chi_squared_manual'] = chi_squared_manual

# Reduced Chi-Squared (manual calculation)
reduced_chi_squared_manual = chi_squared_manual / results['degrees_of_freedom']
results['reduced_chi_squared_manual'] = reduced_chi_squared_manual

# Generate predicted values
y_pred = function(results['fit_params'], x + delta_x) #????
results['y_pred'] = y_pred

# Unweighted residuals for unweighted metrics
unweighted_residuals = y_obs - y_pred
results['unweighted_residuals'] = unweighted_residuals

# Sum of Squares and R-squared metrics
rss_unweighted = np.sum(unweighted_residuals**2)
unweighted_centered_tss = np.sum((y_obs - np.mean(y_obs))**2)
r_squared_unweighted = 1 - rss_unweighted / unweighted_centered_tss
results['r_squared_unweighted'] = r_squared_unweighted

# Note: ODR does not have a concept of weighted R-squared as standard curve_fit.
# The goodness-of-fit is primarily assessed by the reduced chi-squared.

# Information Criteria (using the log-likelihood for ODR, which is implicitly
# based on the chi-squared statistic, assuming a Gaussian error model).
n = results['number_of_observations']
p = results['number_of_parameters']

# A simplified log-likelihood for ODR, based on the chi-squared value.
# This is a good approximation for comparison purposes.
llf = -0.5 * results['chi_squared_manual'] - n/2 * np.log(2*np.pi) - np.sum(np.log(sigma_x)) - np.sum(np.log(sigma_y))

aic = -2 * llf + 2 * p
bic = -2 * llf + np.log(n) * p
aicc = aic + (2 * p * (p + 1)) / (n - p - 1)

results['log_likelihood'] = llf
results['aic'] = aic
results['bic'] = bic
results['aicc'] = aicc
------------------


[31m---------------------------------------------------------------------------[39m
[31mNameError[39m                                 Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[6][39m[32m, line 42[39m
[32m     39[39m results[[33m'[39m[33mreduced_chi_squared_manual[39m[33m'[39m] = reduced_chi_squared_manual
[32m     41[39m [38;5;66;03m# Generate predicted values[39;00m
[32m---> [39m[32m42[39m y_pred = [43mfunction[49m(results[[33m'[39m[33mfit_params[39m[33m'[39m], x + delta_x) [38;5;66;03m#????[39;00m
[32m     43[39m results[[33m'[39m[33my_pred[39m[33m'[39m] = y_pred
[32m     45[39m [38;5;66;03m# Unweighted residuals for unweighted metrics[39;00m

[31mNameError[39m: name 'function' is not defined

